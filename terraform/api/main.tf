# A Lambda API pattern that executes a zipped NodeJS function 
# from an S3 bucket to get around the 50MB direct upload file size limt

### 1. Setup S3 Bucket for Zipped API code
# Set up random bucket naming
resource "random_pet" "api_bucket_name" {
  prefix = "${local.name.prefix}-api"
  length = 2
}

# Define S3 Bucket
resource "aws_s3_bucket" "api_bucket" {
  bucket        = random_pet.api_bucket_name.id
  force_destroy = true
}

# Block Public Access to S3 API Lambda Bucket
resource "aws_s3_bucket_public_access_block" "api_access_policy" {
  bucket = aws_s3_bucket.api_bucket.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

### 2. Set up Lambda access via IAM
# Define a policy to allow executing lambdas
resource "aws_iam_role" "api_lambda_exec" {
  name = "${random_pet.api_bucket_name.id}-api-lambda-exec"

  assume_role_policy = templatefile("${path.module}/policies/lambda-execution-policy.json", {})
}

# Attach this policy to a basic lambda execution role for API GATEWAY
resource "aws_iam_role_policy_attachment" "api_lambda_policy_api_gw" {
  role       = aws_iam_role.api_lambda_exec.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# Attach VPC policy to same exectution role for Lambdas internet access inside VPC/NAT Gateway
resource "aws_iam_role_policy_attachment" "api_lambda_policy_vpc" {
  role       = aws_iam_role.api_lambda_exec.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}


### 3. Setup Lambda Function
resource "aws_lambda_function" "api" {
  function_name = "${local.name.prefix}-api"

  s3_bucket = aws_s3_bucket.api_bucket.id
  s3_key    = aws_s3_object.lambda_api.key

  runtime = "nodejs16.x"
  handler = "app.handler"

  source_code_hash = data.archive_file.lambda_api_zip.output_base64sha256

  # Passed in from split state file: networking.tf
  role = aws_iam_role.api_lambda_exec.arn
  # reintegrated for single network configuration
  # data.terraform_remote_state.networking.outputs.api_lambda_exec.arn
  
  

  timeout = 30

  vpc_config {
    subnet_ids = [data.terraform_remote_state.networking.outputs.private_subnet_id] # [aws_subnet.jd-private.id]
    security_group_ids = [data.terraform_remote_state.networking.outputs.vpc_security_group_id] # [aws_security_group.jd-default-vpc-sg.id]
  }

  # Pattern for ingesting .env file
  dynamic "environment" {
    for_each = local.env != null ? local.env[*] : []
    content {
      variables = environment.value
    }
  }

  # Pattern for hard coded environment variables
  # environment {
  #   variables = {
  #     # Environment Settings
  #     STAGE = "${var.stage}"
  #     NODE_ENV = "${var.stage}"
  #     API_STAGE = "/${var.stage}"
  #   }
  # }
}

# The function as a ZIP - should be generated by CI/CD process
data "archive_file" "lambda_api_zip" {
  type = "zip"

  source_dir  = "${path.module}/../../api"
  output_path = "${path.module}/../../assets/${local.name.prefix}-api.zip"
}

# Upload ZIP artifact to S3 bucket
resource "aws_s3_object" "lambda_api" {
  bucket = aws_s3_bucket.api_bucket.id

  key    = "${local.name.prefix}-api.zip"
  source = data.archive_file.lambda_api_zip.output_path

  # Use source_hash instead as there's a 16MB limit 
  # where uploads will become multi-part zips on S3 with 
  # using etag as the trigger
  # etag = filemd5(data.archive_file.lambda_api_zip.output_path)
  source_hash = filemd5(data.archive_file.lambda_api_zip.output_path)
}

# Logging for lambda console.log statements
resource "aws_cloudwatch_log_group" "api" {
  name = "/aws/lambda/${aws_lambda_function.api.function_name}"

  retention_in_days = 14 # 14 or 30 is recommended depending on CI/CD env
}

### 4. Set up API Gateway to trigger the above Lambda f(x), return the reponse,
### and log transactions for a retention of 14 days
# Configure API Gateway to handle HTTP protocol
resource "aws_apigatewayv2_api" "main" {
  name          = "main"
  protocol_type = "HTTP"
}

# Set up stage environment - we'll just do DEV for now
resource "aws_apigatewayv2_stage" "api_stage" {
  api_id = aws_apigatewayv2_api.main.id

  name        = "${var.stage}"
  auto_deploy = true

  #optional - logging
  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.main_api_gw.arn

    format = jsonencode({
      requestId               = "$context.requestId"
      sourceIp                = "$context.identity.sourceIp"
      requestTime             = "$context.requestTime"
      protocol                = "$context.protocol"
      httpMethod              = "$context.httpMethod"
      resourcePath            = "$context.resourcePath"
      routeKey                = "$context.routeKey"
      status                  = "$context.status"
      responseLength          = "$context.responseLength"
      integrationErrorMessage = "$context.integrationErrorMessage"
    })
  }
}

# Store log into CloudWatch log group
resource "aws_cloudwatch_log_group" "main_api_gw" {
  name = "/aws/${local.name.prefix}-api-gw/${aws_apigatewayv2_api.main.name}"

  retention_in_days = 30 # 14 or 30 is recommended depending on env/pipeline
}

### 5. Integrate API Gateway with Lambda 
resource "aws_apigatewayv2_integration" "api_gw_integration" {
  api_id = aws_apigatewayv2_api.main.id

  # AWS Recommended pattern for RESTful API 
  integration_uri = aws_lambda_function.api.invoke_arn
  integration_type = "AWS_PROXY"
  integration_method = "POST"
}

# Define Endpoint Route to passthrough everything
# because our NodeJS function will handle every endpoint
resource "aws_apigatewayv2_route" "any" {
  api_id = aws_apigatewayv2_api.main.id

  route_key = "$default" 
  target = "integrations/${aws_apigatewayv2_integration.api_gw_integration.id}"  
}

# resource "aws_apigatewayv2_route" "get_name" {
#   api_id = aws_apigatewayv2_api.main.id

#   route_key = "GET /hello"
#   target = "integrations/${aws_apigatewayv2_integration.api_gw_integration.id}"  
# }

# resource "aws_apigatewayv2_route" "post_name" {
#   api_id = aws_apigatewayv2_api.main.id

#   route_key = "POST /hello"
#   target = "integrations/${aws_apigatewayv2_integration.api_gw_integration.id}"  
# }

#Add permissions to API Gateway to Invoke the Lambda Function
resource "aws_lambda_permission" "api_gw" {
  statement_id = "AllowExecutionFromAPIGateway"
  action = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api.function_name
  principal = "apigateway.amazonaws.com"

  source_arn = "${aws_apigatewayv2_api.main.execution_arn}/*/*"
}